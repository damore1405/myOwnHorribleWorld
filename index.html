<!DOCTYPE html>
<meta charset="utf-8">
<body style="margin: unset; overflow: hidden">
<script src="//d3js.org/d3.v4.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<script>
    var print = function (x) {
        console.log(x);
    }

    window.addEventListener('resize',function () {
        width = parseInt(window.innerWidth);
        height = parseInt(window.innerHeight);
        d3.select("canvas").attr("width", width).attr("height", height);
        projection.fitSize([width, height], land);
    });

    var context;
    var path;
    var projection;
    var land;

    var width = parseInt(window.innerWidth),
        height = parseInt(window.innerHeight);

    var radius = height / 2 - 9,
        scale = radius,
        velocity = .017;

    var addPing = function (lng, lat, options) {
        options = options || {};
        options.color = options.color || 'white';
        options.angle = options.angle || 5;
        options.ttl = options.ttl || 2000;
        var ping = {time: new Date(), options: options};
        ping.lng = lng;
        ping.lat = lat;
        pings.push(ping);
    };

    var drawPings = function (context, now) {
        var newPings = [];
        for (var i = 0; i < pings.length; i++) {
            var ping = pings[i];
            var alive = now - ping.time;
            if (alive < ping.options.ttl) {
                newPings.push(ping);
                drawPing(context, now, alive, ping);
            }
        }
        pings = newPings;
    };

    var drawPing = function (context, now, alive, ping) {
        var alpha = 1 - (alive / ping.options.ttl);
        var color = d3.rgb(ping.options.color);
        color = "rgba(" + color.r + "," + color.g + "," + color.b + "," + alpha + ")";
        context.strokeStyle = color;
        var circle = d3.geoCircle()
            .origin([ping.lng, ping.lat])
            .angle(alive / ping.options.ttl * ping.options.angle)();
        context.beginPath();
        path.context(context)(circle);
        context.stroke();
    }

    d3.json("/world-110m.json", function (error, world) {
        if (error) throw error;


        land = topojson.feature(world, world.objects.land);
        projection = d3.geoMercator();
        projection.fitSize([width, height], land);
        // projection.fitHeight(height, land);

        var canvas = d3.select("body").append("canvas")
            .attr("width", width)
            .attr("height", height);

        context = canvas.node().getContext("2d");

        path = d3.geoPath()
            .projection(projection)
            .context(context);

        // context.clearRect(0, 0, width, height);

        // render the 'ocean' below the land
        d3.timer(function (elapsed) {
            renderFrame(elapsed, land)
        });
    });

    // get all pings here, for now ill just fake them
    var pings = [
        {
            lat: -74.00,
            lon: 40.71,
            time: new Date().getTime(),
        },
        {
            lat: -64.00,
            lon: 40.71,
            time: new Date().getTime(),
        }
    ];

    var renderFrame = function (elapsed, land) {
        // projection.rotate([velocity * elapsed, 0]);

        context.beginPath();
        path.context(context)({type: 'Sphere'});
        context.fillStyle = 'lightgrey';
        context.strokeStyle = '#2a3b84';
        // context.lineWidth = '15';
        context.stroke();
        context.fill();

        // render the land
        context.beginPath();
        path.context(context)(land);
        context.fillStyle = '#2a3b84';
        context.fill();


        var drawPings = function(pings) {
            for (var x in pings) {
                var ping = pings[x];
                var now = new Date().getTime();
//                print(ping);

                var timediff = Math.abs(ping.time - now);

                var color = d3.rgb('white');
                var alpha = 1000 / timediff;

                if (alpha < .3) {
                    ping.time = new Date().getTime();
                }


                color = "rgba(" + color.r + "," + color.g + "," + color.b + "," + alpha + ")";
                var circle = d3.geoCircle().center([ping.lat, ping.lon]).radius(timediff / 900)();
                context.opacity = 10;
                context.beginPath();
                context.strokeStyle = color;
                context.fillStyle = color;
                path.context(context)(circle);
                context.fill();
                context.stroke();

            }
        }

       drawPings(pings);

    };

    d3.select(self.frameElement).style("height", height + "px");

</script>
